\documentclass[a4paper,12pt,titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[margin=1in]{geometry}
\usepackage{parskip}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{color}
\hypersetup{
	colorlinks,
	pdfauthor=Delan Azabani,
	pdftitle=Operating Systems 200 Assignment:
	         CPU scheduling with POSIX Threads
}
\lstset{basicstyle=\ttfamily, basewidth=0.5em}

\title{Operating Systems 200 Assignment\\
       CPU scheduling with POSIX Threads}
\date{May 19, 2014}
\author{Delan Azabani (17065012)}

\begin{document}

\maketitle

\section{Read me}

This assignment should compile and run on any reasonably POSIX compliant
environment. Where possible, \texttt{valgrind} and ThreadSanitizer have been
used to check for and eliminate memory leaks, invalid accesses and thread race
conditions. The assignment was tested and debugged using \texttt{gdb} on the
following platforms:

\begin{itemize}
	\item \texttt{neptune.azabani.com} ---
	      Cygwin x86-64,
	      \texttt{gcc} 4.8.2,
	      GNU \texttt{make} 4.0
	\item \texttt{ark.cs.curtin.edu.au} ---
	      Linux 2.6.19 x86-32,
	      \texttt{gcc} 4.0.2,
	      GNU \texttt{make} 3.80
	\item \texttt{ling.comssa.org.au} ---
	      Linux 3.2.0 x86-64,
	      \texttt{clang} 3.5,
	      NetBSD \texttt{pmake} 1.111
\end{itemize}

Instructions for compilation and execution:

\begin{itemize}
	\item To compile all binaries and the report, type \texttt{make}
	\item To compile only the binaries, type \texttt{make binaries}
	\item To compile only the report, type \texttt{make report.pdf}
	\item To delete all generated files, type \texttt{make clean}
	\item To run the standalone RR simulator, type \texttt{./robin}
	\item To run the standalone SJF simulator, type \texttt{./sjf}
	\item To run the threaded simulator, type \texttt{./simulator}
\end{itemize}

\section{Testing the program and known issues}

In addition to memory testing with \texttt{valgrind}, the assignment has been
tested both in the threaded simulator and standalone schedulers with a small
test suite. The output of the Round Robin and Shortest Job First
implementations was successfully compared with the results of scheduling the
jobs by hand on paper.

One of the input test cases, \texttt{test3}, is identical to question 3(e)(i)
of this semester's Mid-Semester Test. Because the answer to this question is
widely known, it eliminates the possibility that my own understanding of the
algorithms may be incorrect. This test case has helped me fix a subtle bug in
my Round Robin scheduler --- see the last assumption in this report for more
details.

Corner cases such as an input file with no jobs are handled somewhat gracefully
by returning the IEEE 754 binary64 \texttt{NaN} value for both averages, which
are generated by evaluating \texttt{0.0 / 0.0}. Because the ISO C99 standard
does not require implementations to use IEEE 754 or provide \texttt{NaN}
values, this may limit portability to an extent.

When running on \texttt{ark.cs.curtin.edu.au}, the threaded simulator will leak
272 bytes on exit. This memory was allocated by \texttt{pthread\_create(3)} and
is not freed due to a bug in the long obsolete GNU C Library 2.3.6.

\newpage

\section{Mutual exclusion and thread synchronisation}

The input and output buffers, known as \texttt{buffer1} and \texttt{buffer2}
in the specification, are called \texttt{char *filename} and
\texttt{os200\_result result} in the assignment code.

Synchronisation of the execution and shared data between the parent thread and
the two scheduler threads is achieved by using a combination of the following
structures, which I'll henceforth refer to as a `synchroniser' for the lack of
better terminology:

\begin{itemize}
	\item one binary state variable (\texttt{int}),
	\item one POSIX condition variable (\texttt{pthread\_cond\_t}), and
	\item one POSIX mutex (\texttt{pthread\_mutex\_t}).
\end{itemize}

The condition variable allows one thread to wake another waiting thread, while
the mutex is used to prevent race conditions in both the synchroniser and any
associated shared data. The state variable initially seems unnecessary due to
the existence of the condition variable, but it achieves at least two goals:

\begin{itemize}
	\item it provides an independent predicate to evaluate which represents
	      the state of the signal, mitigating the effect of spurious
	      wakeups, and
	\item it allows a thread to start waiting on a synchroniser after a
	      signal has been sent and still receive it, without that signal
	      being lost.
\end{itemize}

The parent thread spawns the two child threads, but does not need to wait for
the children to become ready before accepting the first filename. This is
because the aforementioned state variable allows the parent to send the
\texttt{robin} and \texttt{sjf} signals to wake up the children even before
they start listening, without the children hanging.

When a file is input and the two children are awakened, they proceed to
simulate CPU scheduling with their respective algorithms. Once this completes,
they use the \texttt{OS200\_SYNC\_SET\_SIGNAL} macro to safely:

\begin{enumerate}
	\item acquire a lock on \texttt{result}, then
	\item write the averages to the buffer, then
	\item signal the parent thread to print the results.
\end{enumerate}

The parent thread simply waits twice on the same buffer to receive results from
the two schedulers. This method has the perhaps imperfect consequence of making
the order in which the scheduler results are printed non-deterministic.

To politely instruct the scheduler threads to terminate, the \texttt{quit}
variable is set by the parent thread, and the children are once again awakened.
The children see the value of \texttt{quit}, then exit accordingly. No explicit
locking or synchronisation is required for the \texttt{filename} buffer because
the workflow above provides the following guarantees:

\begin{itemize}
	\item no child will be running while the \texttt{filename} is being
	      written to, and
	\item only the parent thread will ever write to \texttt{filename}.
\end{itemize}

\newpage

\section{Assumptions made}

Input files are assumed to conform to the expected format as outlined in the
assignment specification. Scarce checking is done other than ensuring that the
file exists, is readable, and has at least one job entry.

The file format for input to the Shortest Job First scheduler shall be the same
as for the Round Robin scheduler, that is, the first line contains a quantum
value. The quantum value is simply ignored by the SJF scheduler, much like
priorities would be ignored if they were included in a SJF or FCFS scheduler.

Where multiple jobs arrive at the Round Robin scheduler simultaneously, they
are queued in the same order as they appear in the input file. The jobs are not
further sorted by duration, for example.

There are two variants of Shortest Job First scheduling: non-preemptive and
preemptive, the latter of which is also known as Shortest Remaining Time First.
Because the variety of the scheduler was not specified, and the alternative
name was not used, it is assumed that the SJF scheduler is non-preemptive.

A maximum filename length of 10 bytes is \textit{not} assumed. The
\texttt{os200\_read\_line} function implements a means to read a filename of
virtually unlimited length from standard input, requiring only $O(\lg n)$ calls
to \texttt{realloc(3)}.

When a job in the Round Robin scheduler has not completed its entire execution
after one of its time slices, it is assumed that the job should be requeued
\textit{after} newly arriving jobs are enqueued. The order --- before or after
--- is not specified in the lecture slides nor the textbook, but I have made
this choice because it matches the method required to answer the question
3(e)(i) of this semester's Mid-Semester Test.

\newpage

\section{Sample input and output listing}

\begin{lstlisting}
$ ./simulator
Simulation: _
sjf-backend.c:29: os200_sjf_file: _: No such file or directory
robin-backend.c:29: os200_robin_file: _: No such file or directory
RR:  average turnaround: nan, average waiting: nan
SJF: average turnaround: nan, average waiting: nan
Simulation: test0
RR:  average turnaround: nan, average waiting: nan
SJF: average turnaround: nan, average waiting: nan
Simulation: test1
RR:  average turnaround: 114.428571, average waiting: 83.285714
SJF: average turnaround: 77.285714, average waiting: 46.142857
Simulation: test2
RR:  average turnaround: 46.666667, average waiting: 20.000000
SJF: average turnaround: 56.666667, average waiting: 30.000000
Simulation: test3
RR:  average turnaround: 8.400000, average waiting: 4.800000
SJF: average turnaround: 7.600000, average waiting: 4.000000
Simulation: QUIT

$ cat test0
5

$ cat test1
5
1 24
1 23
3 1
4 20
4 100
12 30
20 20

$ cat test2
10
10 50
20 20
20 10

$ cat test3
2
0 7
1 3
5 2
7 2
8 4
\end{lstlisting}

\end{document}
