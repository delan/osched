\documentclass[a4paper,12pt,titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[margin=1in]{geometry}
\usepackage{parskip}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{color}
\hypersetup{
	colorlinks,
	pdfauthor=Delan Azabani,
	pdftitle=Operating Systems 200 Assignment:
	         CPU scheduling with POSIX Threads
}
\lstset{basicstyle=\ttfamily\scriptsize, basewidth=0.5em}

\title{Operating Systems 200 Assignment\\
       CPU scheduling with POSIX Threads}
\date{May 19, 2014}
\author{Azabani, Delan\\17065012}

\begin{document}

\maketitle

\section{Read me}

This assignment should compile and run on any reasonably POSIX compliant
environment. Where possible, \texttt{valgrind} and ThreadSanitizer have been
used to check for and eliminate memory leaks, invalid accesses and thread race
conditions. The assignment was tested and debugged using \texttt{gdb} on the
following platforms:

\begin{itemize}
	\item \texttt{neptune.azabani.com}\\
	      Cygwin x86-64,
	      \texttt{gcc} 4.8.2,
	      GNU \texttt{make} 4.0
	\item \texttt{ark.cs.curtin.edu.au}\\
	      Linux 2.6.19 x86-32,
	      \texttt{gcc} 4.0.2,
	      GNU \texttt{make} 3.80,
	      \texttt{valgrind} 2.4.0
	\item \texttt{ling.comssa.org.au}\\
	      Linux 3.2.0 x86-64,
	      \texttt{clang} 3.5,
	      NetBSD \texttt{pmake} 1.111,
	      \texttt{valgrind} 3.7.0
\end{itemize}

Instructions for compilation and execution:

\begin{itemize}
	\item To compile all binaries and the report, type \texttt{make}
	\item To compile only the binaries, type \texttt{make binaries}
	\item To compile only the report, type \texttt{make report.pdf}
	\item To delete all generated files, type \texttt{make clean}
	\item To run the standalone Round Robin simulator,
	      type \texttt{./robin}
	\item To run the standalone Shortest Job First simulator,
	      type \texttt{./sjf}
	\item To run the threaded simulator, type \texttt{./simulator}
\end{itemize}

\newpage

\section{Program testing and known issues}

In addition to testing with \texttt{gdb}, \texttt{valgrind} and
ThreadSanitizer, the assignment has been tested both in the threaded simulator
and standalone schedulers with a small test suite. The output of the Round
Robin and Shortest Job First implementations was successfully compared with the
results of scheduling the jobs by hand on paper.

One of the input test cases, \texttt{test3}, is identical to question 3(e)(i)
of this semester's Mid-Semester Test. Because the answer to this question is
widely known, it eliminates the possibility that my own understanding of the
algorithms may be incorrect. This test case has helped me fix a subtle bug in
my Round Robin scheduler during development --- see the last assumption in this
report for more details.

To reduce the likelihood of bugs that only appear after many simulation cycles,
I have created a file, \texttt{testbig}, which consists of the filenames of the
test cases repeated 10000 times each. This is piped into the threaded simulator
for a `stress test'.

Corner cases such as an input file with no jobs are handled somewhat gracefully
by returning the IEEE 754 binary64 \texttt{NaN} value for both averages,
generated by evaluating \texttt{0.0 / 0.0}. Because the ISO C99 standard does
not require implementations to use IEEE 754 or provide \texttt{NaN} values,
this may limit portability to an extent.

When running on \texttt{ark.cs.curtin.edu.au}, the threaded simulator will leak
272 bytes on exit. This memory was allocated by \texttt{pthread\_create(3)} and
is not freed due to a bug in the long obsolete GNU C Library 2.3.6.

\newpage

\section{Mutual exclusion and thread synchronisation}

The input and output buffers, known as \texttt{buffer1} and \texttt{buffer2}
in the specification, are called \texttt{char *filename} and
\texttt{os200\_result result} in the assignment code.

Synchronisation of the execution and shared data between the parent thread and
the two scheduler threads is achieved by using a combination of the following
structures, which I'll henceforth refer to as a `synchroniser' for the lack of
better terminology:

\begin{itemize}
	\item one binary state variable (\texttt{int}),
	\item one POSIX condition variable (\texttt{pthread\_cond\_t}), and
	\item one POSIX mutex (\texttt{pthread\_mutex\_t}).
\end{itemize}

The condition variable allows one thread to wake another waiting thread, while
the mutex is used to prevent race conditions in both the synchroniser and any
associated shared data. The state variable initially seems unnecessary due to
the existence of the condition variable, but it achieves at least two goals:

\begin{itemize}
	\item it provides an independent predicate to evaluate which represents
	      the state of the signal, mitigating the effect of spurious
	      wakeups, and
	\item it allows a thread to start waiting on a synchroniser after a
	      signal has been sent and still receive it, without that signal
	      being lost.
\end{itemize}

The parent thread spawns the two child threads, but does not need to wait for
the children to become ready before accepting the first filename. This is
because the aforementioned state variable allows the parent to send the
\texttt{robin} and \texttt{sjf} signals to wake up the children even before
they start listening, without the children hanging.

When a file is input and the two children are awakened, they proceed to
simulate CPU scheduling with their respective algorithms. Once this completes,
they use the \texttt{OS200\_SYNC\_SET\_SIGNAL} macro to safely:

\begin{enumerate}
	\item acquire a lock on \texttt{result}, then
	\item write the averages to the buffer, then
	\item signal the parent thread to print the results.
\end{enumerate}

The parent thread simply waits twice on the same buffer to receive results from
the two schedulers. This method has the perhaps imperfect consequence of making
the order in which the scheduler results are printed non-deterministic.

To politely instruct the scheduler threads to terminate, the \texttt{quit}
variable is set by the parent thread, and the children are once again awakened.
The children see the value of \texttt{quit}, then exit accordingly. No explicit
locking or synchronisation is required for the \texttt{filename} buffer because
the workflow above provides the following guarantees:

\begin{itemize}
	\item no child will be running while the \texttt{filename} is being
	      written to, and
	\item only the parent thread will ever write to \texttt{filename}.
\end{itemize}

\newpage

\section{Assumptions made}

Input files are assumed to conform to the expected format as outlined in the
assignment specification. Scarce checking is done other than ensuring that the
file exists, is readable, and has at least one job entry.

The file format for input to the Shortest Job First scheduler shall be the same
as for the Round Robin scheduler, that is, the first line contains a quantum
value. The quantum value is simply ignored by the SJF scheduler, much like
priorities would be ignored if they were included in a SJF or FCFS scheduler.

Where multiple jobs arrive at the Round Robin scheduler simultaneously, they
are queued in the same order as they appear in the input file. The jobs are not
further sorted by duration, for example.

There are two variants of Shortest Job First scheduling: non-preemptive and
preemptive, the latter of which is also known as Shortest Remaining Time First.
Because the variety of the scheduler was not specified, and the alternative
name was not used, it is assumed that the SJF scheduler is non-preemptive.

A maximum filename length of 10 bytes is \textit{not} assumed. The
\texttt{os200\_read\_line} function implements a means to read a filename of
virtually unlimited length from standard input, requiring only $O(\lg n)$ calls
to \texttt{realloc(3)}.

When a job in the Round Robin scheduler has not completed its entire execution
after one of its time slices, it is assumed that the job should be requeued
\textit{after} newly arriving jobs are enqueued. The order --- before or after
--- is not specified in the lecture slides nor the textbook, but I have made
this choice because it matches the method required to answer the question
3(e)(i) of this semester's Mid-Semester Test.

\newpage

\section{Sample input and output listings}

\subsection{Basic execution on \texttt{ling.comssa.org.au}}

\begin{lstlisting}
ling% pmake CC=clang clean all > /dev/null && ./simulator
Simulation: test0
RR:   average turnaround: nan, average waiting: nan
SJF:  average turnaround: nan, average waiting: nan
Simulation: test1
SJF:  average turnaround: 77.285714, average waiting: 46.142857
RR:   average turnaround: 114.428571, average waiting: 83.285714
Simulation: test2
SJF:  average turnaround: 56.666667, average waiting: 30.000000
RR:   average turnaround: 46.666667, average waiting: 20.000000
Simulation: test3
RR:   average turnaround: 8.400000, average waiting: 4.800000
SJF:  average turnaround: 7.600000, average waiting: 4.000000
Simulation: test4
sjf-backend.c:29: os200_sjf_file: test4: No such file or directory
robin-backend.c:29: os200_robin_file: test4: No such file or directory
RR:   average turnaround: nan, average waiting: nan
SJF:  average turnaround: nan, average waiting: nan
Simulation: QUIT

ling% cat test0
5

ling% cat test1
5
1 24
1 23
3 1
4 20
4 100
12 30
20 20

ling% cat test2
10
10 50
20 20
20 10

ling% cat test3
2
0 7
1 3
5 2
7 2
8 4
\end{lstlisting}

\newpage

\subsection{\texttt{valgrind} on \texttt{ark.cs.curtin.edu.au}}

\begin{lstlisting}
17065012@ark ~/OS200/assignment/osched
$ valgrind --leak-check=full ./simulator < testbig > /dev/null
==11481== Memcheck, a memory error detector for x86-linux.
==11481== Copyright (C) 2002-2005, and GNU GPL'd, by Julian Seward et al.
==11481== Using valgrind-2.4.0, a program supervision framework for x86-linux.
==11481== Copyright (C) 2000-2005, and GNU GPL'd, by Julian Seward et al.
==11481== For more details, rerun with: -v
==11481==
==11481==
==11481== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 14 from 1)
==11481== malloc/free: in use at exit: 272 bytes in 2 blocks.
==11481== malloc/free: 1680004 allocs, 1680002 frees, 53280289 bytes allocated.
==11481== For counts of detected errors, rerun with: -v
==11481== searching for pointers to 2 not-freed blocks.
==11481== checked 16851216 bytes.
==11481==
==11481== 272 bytes in 2 blocks are possibly lost in loss record 1 of 1
==11481==    at 0x1B909B71: calloc (vg_replace_malloc.c:175)
==11481==    by 0x1B8F47B5: _dl_allocate_tls (in /lib/ld-2.3.6.so)
==11481==    by 0x4F34458C: pthread_create@@GLIBC_2.1 (in /lib/libpthread-2.3.6.so)
==11481==    by 0x8049013: main (simulator.c:51)
==11481==
==11481== LEAK SUMMARY:
==11481==    definitely lost: 0 bytes in 0 blocks.
==11481==      possibly lost: 272 bytes in 2 blocks.
==11481==    still reachable: 0 bytes in 0 blocks.
==11481==         suppressed: 0 bytes in 0 blocks.
==11481== Reachable blocks (those to which a pointer was found) are not shown.
==11481== To see them, rerun with: --show-reachable=yes
\end{lstlisting}

\subsection{\texttt{valgrind} on \texttt{ling.comssa.org.au}}

\begin{lstlisting}
ling% valgrind --leak-check=full ./simulator < testbig > /dev/null
==9214== Memcheck, a memory error detector
==9214== Copyright (C) 2002-2011, and GNU GPL'd, by Julian Seward et al.
==9214== Using Valgrind-3.7.0 and LibVEX; rerun with -h for copyright info
==9214== Command: ./simulator
==9214==
==9214==
==9214== HEAP SUMMARY:
==9214==     in use at exit: 0 bytes in 0 blocks
==9214==   total heap usage: 1,680,004 allocs, 1,680,004 frees, 85,200,561 bytes allocated
==9214==
==9214== All heap blocks were freed -- no leaks are possible
==9214==
==9214== For counts of detected and suppressed errors, rerun with: -v
==9214== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 4 from 4)
\end{lstlisting}

\end{document}
