\documentclass[a4paper,12pt,titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[margin=1in]{geometry}
\usepackage{parskip}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{color}
\hypersetup{
	colorlinks,
	pdfauthor=Delan Azabani,
	pdftitle=Operating Systems 200 Assignment:
	         CPU scheduling with POSIX Threads
}
\lstset{basicstyle=\ttfamily, basewidth=0.5em}

\title{Operating Systems 200 Assignment\\
       CPU scheduling with POSIX Threads}
\date{May 18, 2014}
\author{Delan Azabani}

\begin{document}

\maketitle

\section{Read me}

This assignment should compile and run on any reasonably POSIX compliant
environment. Where possible, \texttt{valgrind} and ThreadSanitizer have been
used to check for and eliminate memory leaks, invalid accesses and thread race
conditions. The assignment was tested and debugged using \texttt{gdb} on the
following platforms:

\begin{itemize}
	\item \texttt{neptune.azabani.com} ---
	      Cygwin x86-64,
	      \texttt{gcc} 4.8.2,
	      GNU \texttt{make} 4.0
	\item \texttt{ark.cs.curtin.edu.au} ---
	      Linux 2.6.19 x86-32,
	      \texttt{gcc} 4.0.2,
	      GNU \texttt{make} 3.80
	\item \texttt{ling.comssa.org.au} ---
	      Linux 3.2.0 x86-64,
	      \texttt{clang} 3.5,
	      NetBSD \texttt{pmake} 1.111
\end{itemize}

Instructions for compilation and execution:

\begin{itemize}
	\item To compile all binaries and the report, type \texttt{make}
	\item To compile only the binaries, type \texttt{make binaries}
	\item To compile only the report, type \texttt{make report.pdf}
	\item To delete all generated files, type \texttt{make clean}
	\item To run the standalone RR simulator, type \texttt{./robin}
	\item To run the standalone SJF simulator, type \texttt{./sjf}
	\item To run the threaded simulator, type \texttt{./simulator}
\end{itemize}

\section{Testing the program and known issues}

In addition to memory testing with \texttt{valgrind}, the assignment has been
tested both in the threaded simulator and standalone schedulers with a small
test suite. The output of the Round Robin and Shortest Job First
implementations was successfully compared with the results of scheduling the
jobs by hand on paper.

One of the input test cases, \texttt{test3}, is identical to question 3(e)(i)
of this semester's Mid-Semester Test. Because the answer to this question is
widely known, it eliminates the possibility that my own understanding of the
algorithms may be incorrect. This test case has helped me fix a subtle bug in
my Round Robin scheduler --- see the last assumption in this report for more
details.

Corner cases such as an input file with no jobs are handled somewhat gracefully
by returning the IEEE 754 binary64 \texttt{NaN} value for both averages, which
are generated by evaluating \texttt{0.0 / 0.0}. Because the ISO C99 standard
does not require implementations to use IEEE 754 or provide \texttt{NaN}
values, this may limit portability to an extent.

When running on \texttt{ark.cs.curtin.edu.au}, the threaded simulator will leak
272 bytes on exit. This memory was allocated by \texttt{pthread\_create(3)} and
is not freed due to a bug in the long obsolete GNU C Library 2.3.6.

\newpage

\section{Mutual exclusion and thread synchronisation}

The coordination of reads and writes with the \texttt{robin\_result} and
\texttt{sjf\_result} buffers involves the use of the following supporting
data structures for each:

\begin{itemize}
	\item one binary state variable denoting `readiness' (\texttt{int}),
	\item one POSIX mutex (\texttt{pthread\_mutex\_t}), and
	\item one POSIX condition variable (\texttt{pthread\_cond\_t}).
\end{itemize}

The main thread spawns the child threads, then waits for the two
aforementioned buffers to be filled. This is achieved by using
\texttt{OS200\_WAIT}, a function-like macro which:

\begin{enumerate}
	\item acquires the mutex associated with the buffer, then
	\item calls \texttt{pthread\_cond\_wait}, which:
	\begin{enumerate}
		\item atomically releases the buffer's mutex, then
		\item blocks until the condition variable is signalled, then
		\item acquires the mutex associated with the buffer.
	\end{enumerate}
\end{enumerate}

The reason why \texttt{pthread\_cond\_wait} is called repeatedly until a
separate state variable becomes true, is because a condition variable alone is
not enough to avoid spurious wakeups and race conditions. The child threads use
the following procedure with \texttt{OS200\_LOCK} and \texttt{OS200\_SIGNAL}
when writing results to their respective buffers:

\begin{enumerate}
	\item the mutex associated with the buffer is acquired, then
	\item the output data containing average times is written, then
	\item the state variable is set to indicate readiness, then
	\item \texttt{pthread\_cond\_broadcast} is called to wake up the
	      parent thread, then
	\item the mutex associated with the buffer is released.
\end{enumerate}

In the above instances, the mutex protects the condition variable, the state
variable and the shared data itself. A similar technique is used in the
opposite direction, to allow the main thread to wake up both child threads
upon the entry of a filename. This involves the use of two additional sets of
the three ancillary data structures, without shared data to protect. Because
the filename entry and concurrent computation stages of the program are always
sequential, mutual exclusion of accesses to the filename buffer is implicit,
and no additional locking is required.

\newpage

\section{Assumptions made}

Input files are assumed to conform to the expected format as outlined in the
assignment specification. Scarce checking is done other than ensuring that the
file exists, is readable, and has at least one job entry.

The file format for input to the Shortest Job First scheduler shall be the same
as for the Round Robin scheduler, that is, the first line contains a quantum
value. The quantum value is simply ignored by the SJF scheduler, much like
priorities would be ignored if they were included in a SJF or FCFS scheduler.

Where multiple jobs arrive at the Round Robin scheduler simultaneously, they
are queued in the same order as they appear in the input file. The jobs are not
further sorted by duration, for example.

There are two variants of Shortest Job First scheduling: non-preemptive and
preemptive, the latter of which is also known as Shortest Remaining Time First.
Because the variety of the scheduler was not specified, and the alternative
name was not used, it is assumed that the SJF scheduler is non-preemptive.

A maximum filename length of 10 bytes is \textit{not} assumed. The
\texttt{os200\_read\_line} function implements a means to read a filename of
virtually unlimited length from standard input, requiring only $O(\lg n)$ calls
to \texttt{realloc(3)}.

When a job in the Round Robin scheduler has not completed its entire execution
after one of its time slices, it is assumed that the job should be requeued
\textit{after} newly arriving jobs are enqueued. The order --- before or after
--- is not specified in the lecture slides nor the textbook, but I have made
this choice because it matches the method required to answer the question
3(e)(i) of this semester's Mid-Semester Test.

\newpage

\section{Sample input and output listing}

\begin{lstlisting}
$ ./simulator
Simulation: _
sjf-backend.c:29: os200_sjf_file: _: No such file or directory
robin-backend.c:29: os200_robin_file: _: No such file or directory
RR:  average turnaround: nan, average waiting: nan
SJF: average turnaround: nan, average waiting: nan
Simulation: test0
RR:  average turnaround: nan, average waiting: nan
SJF: average turnaround: nan, average waiting: nan
Simulation: test1
RR:  average turnaround: 114.428571, average waiting: 83.285714
SJF: average turnaround: 77.285714, average waiting: 46.142857
Simulation: test2
RR:  average turnaround: 46.666667, average waiting: 20.000000
SJF: average turnaround: 56.666667, average waiting: 30.000000
Simulation: test3
RR:  average turnaround: 8.400000, average waiting: 4.800000
SJF: average turnaround: 7.600000, average waiting: 4.000000
Simulation: QUIT

$ cat test0
5

$ cat test1
5
1 24
1 23
3 1
4 20
4 100
12 30
20 20

$ cat test2
10
10 50
20 20
20 10

$ cat test3
2
0 7
1 3
5 2
7 2
8 4
\end{lstlisting}

\end{document}
